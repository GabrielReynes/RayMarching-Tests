// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct ray
{
    float3 origin;
    float3 direction;
};

struct sphere
{
    float4x4 inverse_local;
    float size;
    float4 col;
};

struct box
{
    float4x4 inverse_local;
    float3 size;
    float4 col;
    float rounding_radius;
};

const float3 light_dir;
const float contour_max = 0.0;
const float4 light_col, background_col, contour_col;

float4x4 camera_to_world;
float4x4 camera_inverse_projection;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> result;
int sphere_count, cube_count;
StructuredBuffer<sphere> spheres;
StructuredBuffer<box> cubes;

ray create_ray(const float3 origin, const float3 direction)
{
    ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

ray create_camera_ray(float2 uv)
{
    const float3 origin = mul(camera_to_world, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    float3 direction = mul(camera_inverse_projection, float4(uv, 0.0f, 1.0f)).xyz;
    direction = mul(camera_to_world, float4(direction, 0.0f)).xyz;
    return create_ray(origin, normalize(direction));
}

inline float3 opTx( in float3 p, in float4x4 t)
{
    return mul(t, float4(p, 1.0f)).xyz;
}

float3 opRep( in float3 p, in float3 c)
{
    const float3 mid = 0.5*c;
    return fmod(p+mid, c) - mid;
}

float4 opElongate( in float3 p, in float3 h )
{
    float3 q = abs(p)-h;
    return float4(max(q,0.0), min(max(q.x,max(q.y,q.z)), 0.0));
}

float sdSphere(const float3 p, const float s )
{
    return length(p) - s;
}

float sdBox(float3 p, float3 b)
{
    float3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float min_dist(float3 pos, out float4 col)
{
    float d = 1.#INF;
    float aux;
    for (int s = 0; s < sphere_count; ++s)
    {
        aux = sdSphere(opTx(pos, spheres[s].inverse_local), spheres[s].size);
        if (aux < d) {d = aux; col = spheres[s].col;}
    }
    for (int c = 0; c < cube_count; ++c)
    {
        aux = sdBox(opTx(pos, cubes[c].inverse_local), cubes[c].size) - cubes[c].rounding_radius;
        if (aux < d) {d = aux; col = cubes[c].col;}
    }
    
    return d;
}

//TODO: Understand
float3 calc_normal(float3 pos, out float4 col)
{
    float2 e = float2(1.0, -1.0);
    const float eps = 5e-4;
    return normalize( e.xyy * min_dist(pos + e.xyy*eps, col) + 
                      e.yyx * min_dist(pos + e.yyx*eps, col) + 
                      e.yxy * min_dist(pos + e.yxy*eps, col) + 
                      e.xxx * min_dist(pos + e.xxx*eps, col));
}

float soft_shadow( in float3 ro, in float3 rd, float mint, float maxt, float k)
{
    float res = 1.0;
    for( float t=mint; t<maxt; )
    {
        float4 garbage;
        float h = min_dist(ro + rd*t, garbage);
        if(h < mint) return 0.0;
        res = min(res, k*h/t);
        t += h;
    }
    return res;
}

[numthreads(16,16,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    result.GetDimensions(width, height);

    const float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

    const ray ray = create_camera_ray(uv);

    float4 col;
    
    float dist_sum = 0.0;
    const float min_step = 1e-4, max_step = 1e3;
    float min_registered = max_step;
    
    for (int i = 0; i < 256; i++)
    {
        const float3 pos = ray.origin + dist_sum * ray.direction;
        
        const float d = min_dist(pos, col);
        min_registered = min(min_registered, d);
        dist_sum += d;
        if (d < min_step || dist_sum > max_step) break;
    }
    
    const float3 pos = ray.origin + dist_sum * ray.direction;
    const float3 nor = calc_normal(pos, col);
    
    const float dif = clamp(dot(nor, -light_dir), 0.0, 1.0);
        // * soft_shadow(pos, -light_dir, min_step, 3.0, 1);
    const float amb = (dot(nor, float3(0, 1, 0)) + 1) / 2;

    const float4 final = sqrt(col*amb + dif*light_col);
    
    if(dist_sum <= max_step) result[id.xy] = final;
    else if (min_registered < contour_max)
        result[id.xy] = contour_col * (contour_max - min_registered) / contour_max;
    else result[id.xy] = background_col;
}
