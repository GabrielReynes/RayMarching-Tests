// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct ray
{
    float3 origin;
    float3 direction;
};

struct sphere
{
    float3 position;
    float size;
    float4 col;
};

struct box
{
    float3 position;
    float3 size;
    float4 col;
};

const float3 light_dir;
const float4 light_col, background_col;

float4x4 camera_to_world;
float4x4 camera_inverse_projection;

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> result;
int sphere_count, cube_count;
StructuredBuffer<sphere> spheres;
StructuredBuffer<box> cubes;

ray create_ray(const float3 origin, const float3 direction)
{
    ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

ray create_camera_ray(float2 uv)
{
    const float3 origin = mul(camera_to_world, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    float3 direction = mul(camera_inverse_projection, float4(uv, 0.0f, 1.0f)).xyz;

    direction = mul(camera_to_world, float4(direction, 0.0f)).xyz;
    return create_ray(origin, normalize(direction));
}

float sdSphere(const float3 p, const float s )
{
    return length(p) - s;
}

float sdBox(float3 p, float3 b)
{
    float3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float4 contour(float dist, float4 col)
{
    if (dist > 1e-1) return float4(1,1,1,1)*(1-dist);
    return col;
}

float min_dist(float3 pos, out float4 col)
{
    float d = 1.#INF;
    float aux;
    for (int s = 0; s < sphere_count; ++s)
    {
        aux = sdSphere(pos-spheres[s].position, spheres[s].size);
        if (aux < d) {d = aux; col = contour(aux, spheres[s].col);}
    }
    for (int c = 0; c < cube_count; ++c)
    {
        aux = sdBox(pos-cubes[c].position, cubes[c].size);
        if (aux < d) {d = aux; col = cubes[c].col;}
    }
    return d;
}

//TODO: Understand
float3 calc_normal(float3 pos, out float4 col)
{
    float2 e = float2(1.0, -1.0);
    const float eps = 5e-4;
    return normalize( e.xyy * min_dist(pos + e.xyy*eps, col) + 
                      e.yyx * min_dist(pos + e.yyx*eps, col) + 
                      e.yxy * min_dist(pos + e.yxy*eps, col) + 
                      e.xxx * min_dist(pos + e.xxx*eps, col));
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    result.GetDimensions(width, height);

    const float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);

    const ray ray = create_camera_ray(uv);

    float4 col;
    
    float dist_sum = 0.0;
    float dist_max = 1e5;
    
    for (int i = 0; i < 256; i++)
    {
        const float3 pos = ray.origin + dist_sum * ray.direction;
        
        const float d = min_dist(pos, col);

        if( d < 1e-4 || dist_sum > dist_max) break;
        dist_sum += d;
    }
    
    const float3 pos = ray.origin + dist_sum * ray.direction;
    float3 nor = calc_normal(pos, col);
    float dif = clamp(dot(nor, -light_dir), 0.0, 1.0);
    float amb = 0.5 + 0.5*dot(nor, float3(0.0, 1.0, 0.0));

    float4 final = sqrt(col*amb + dif*light_col);
    
    if(dist_sum <= dist_max) result[id.xy] = final;
    else result[id.xy] = background_col;
}
